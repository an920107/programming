"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadSync = exports.load = exports.defaultLoadOptions = void 0;
const tslib_1 = require("tslib");
const commentParser = require("./modules/comment-parser");
const crossPlatform = require("./modules/cross-platform");
const path = require("node:path");
const utils = require("./utils");
const load_interfaces_1 = require("./load.interfaces");
const options_defaults_1 = require("options-defaults");
const providers_1 = require("./providers/providers");
exports.defaultLoadOptions = {
    mode: load_interfaces_1.LoadMode.Transpile,
    allowConfigurationWithComments: false,
    useCache: true,
    compiledJsExtension: `.js`,
};
const load = async (tsRelativePath, options) => {
    var _a, _b;
    if (options === null || options === void 0 ? void 0 : options.allowConfigurationWithComments) {
        const commentConfig = await commentParser.getTsImportCommentConfig(tsRelativePath);
        options = (0, options_defaults_1.defaults)(options, commentConfig);
    }
    const loadConfig = (0, options_defaults_1.defaults)(exports.defaultLoadOptions, options);
    const provider = providers_1.providersMap[loadConfig.mode];
    const config = provider.getConfig(loadConfig);
    const cwd = process.cwd();
    const cacheDir = provider.getCacheDir(config);
    const tsPath = path.resolve(cwd, tsRelativePath);
    const jsAfterCachePath = crossPlatform.getJsAfterCachePath(tsPath);
    const jsPath = path.join(cacheDir, jsAfterCachePath).replace(/\.[^/.]+$/u, loadConfig.compiledJsExtension);
    if (loadConfig.useCache) {
        const [tsFileExists, jsFileExists] = await Promise.all([
            utils.checkIfFileExists(tsPath),
            utils.checkIfFileExists(jsPath).catch(() => {
            }),
        ]);
        if (jsFileExists && !utils.isFileNewer(tsFileExists, jsFileExists)) {
            const loaded = await (_a = jsPath, Promise.resolve().then(() => require(_a)));
            return loaded;
        }
    }
    await provider.load(Object.assign({ tsPath,
        jsPath }, config));
    const loaded = await (_b = jsPath, Promise.resolve().then(() => require(_b)));
    return loaded;
};
exports.load = load;
const loadSync = (tsRelativePath, options) => {
    if (options === null || options === void 0 ? void 0 : options.allowConfigurationWithComments) {
        const commentConfig = commentParser.getTsImportCommentConfigSync(tsRelativePath);
        options = (0, options_defaults_1.defaults)(options, commentConfig);
    }
    const loadConfig = (0, options_defaults_1.defaults)(exports.defaultLoadOptions, options);
    const provider = providers_1.providersMap[loadConfig.mode];
    const config = provider.getConfig(loadConfig);
    const cwd = process.cwd();
    const cacheDir = provider.getCacheDir(config);
    const tsPath = path.resolve(cwd, tsRelativePath);
    const jsAfterCachePath = crossPlatform.getJsAfterCachePath(tsPath);
    const jsPath = path.join(cacheDir, jsAfterCachePath).replace(/\.[^/.]+$/u, loadConfig.compiledJsExtension);
    if (loadConfig.useCache) {
        const tsFileExists = utils.checkIfFileExistsSync(tsPath);
        let jsFileExists;
        try {
            jsFileExists = utils.checkIfFileExistsSync(jsPath);
        }
        catch (err) {
        }
        if (jsFileExists && !utils.isFileNewer(tsFileExists, jsFileExists)) {
            const loaded = require(jsPath);
            return loaded;
        }
    }
    provider.loadSync(Object.assign({ tsPath,
        jsPath }, config));
    const loaded = require(jsPath);
    return loaded;
};
exports.loadSync = loadSync;
tslib_1.__exportStar(require("./load.interfaces"), exports);
//# sourceMappingURL=main.js.map